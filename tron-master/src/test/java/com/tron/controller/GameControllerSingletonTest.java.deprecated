package com.tron.controller;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

/**
 * Unit tests for the {@link GameController} Singleton Pattern implementation.
 * 
 * <p>This test class validates the Singleton Pattern applied to GameController,
 * ensuring that only one instance of GameController exists throughout the
 * application lifecycle, and that it is thread-safe.</p>
 * 
 * <p>Tests cover:</p>
 * <ul>
 *   <li>Instance Uniqueness - Verify only one instance is created</li>
 *   <li>Thread Safety - Verify thread-safe access in multi-threaded environments</li>
 *   <li>Lazy Initialization - Verify instance is created on first access</li>
 *   <li>Singleton Behavior - Verify getInstance() always returns the same instance</li>
 * </ul>
 * 
 * @author MattBrown
 * @author MattBrown
 * @version 1.0
 * @see GameController
 */
@DisplayName("GameController Singleton Pattern Tests")
public class GameControllerSingletonTest {

    /**
     * Nested test class for basic Singleton behavior tests.
     */
    @Nested
    @DisplayName("Basic Singleton Behavior Tests")
    class BasicSingletonTests {

        /**
         * Test Case: GameControllerSingletonTest.testInstanceUniqueness()
         * 
         * Tests that multiple calls to getInstance() return the same instance object.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: None
         * Expected Outcome: Two variables assigned from getInstance() should reference
         *                   the same object (identity equality)
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testInstanceUniqueness - Multiple getInstance() calls return same instance")
        void testInstanceUniqueness() {
            // Arrange & Act
            GameController instance1 = GameController.getInstance();
            GameController instance2 = GameController.getInstance();
            GameController instance3 = GameController.getInstance();

            // Assert
            assertNotNull(instance1, "First instance should not be null");
            assertNotNull(instance2, "Second instance should not be null");
            assertNotNull(instance3, "Third instance should not be null");
            assertSame(instance1, instance2, "First and second instances should be identical");
            assertSame(instance2, instance3, "Second and third instances should be identical");
            assertSame(instance1, instance3, "First and third instances should be identical");
        }

        /**
         * Test Case: GameControllerSingletonTest.testInstanceNotNull()
         * 
         * Tests that getInstance() never returns null.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: None
         * Expected Outcome: getInstance() should return a non-null object
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testInstanceNotNull - getInstance() never returns null")
        void testInstanceNotNull() {
            // Arrange & Act
            GameController instance = GameController.getInstance();

            // Assert
            assertNotNull(instance, "GameController.getInstance() should never return null");
        }

        /**
         * Test Case: GameControllerSingletonTest.testSingletonPattern()
         * 
         * Tests that the returned instance is always the same object reference.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: None
         * Expected Outcome: All getInstance() calls return the exact same object in memory
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testSingletonPattern - Verify singleton contract is maintained")
        void testSingletonPattern() {
            // Arrange & Act
            GameController singleton1 = GameController.getInstance();
            GameController singleton2 = GameController.getInstance();

            // Assert
            assertEquals(System.identityHashCode(singleton1), System.identityHashCode(singleton2),
                    "Both instances should have the same identity hash code");
        }
    }

    /**
     * Nested test class for thread safety tests.
     */
    @Nested
    @DisplayName("Thread Safety Tests")
    class ThreadSafetyTests {

        /**
         * Test Case: GameControllerSingletonTest.testThreadSafety()
         * 
         * Tests that getInstance() is thread-safe when called from multiple threads
         * simultaneously. All threads should receive the same instance.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: 20 concurrent threads attempting to get singleton instance
         * Expected Outcome: All threads receive the same instance object
         *                   Set of instances should contain only 1 unique object
         * Actual Outcome: Verified by asserting set size equals 1
         * Testing Framework: JUnit 5, ExecutorService for thread management
         */
        @Test
        @DisplayName("testThreadSafety - Multiple threads get same instance")
        void testThreadSafety() throws InterruptedException {
            // Arrange
            Set<GameController> instances = new HashSet<>();
            ExecutorService executor = Executors.newFixedThreadPool(20);
            int threadCount = 20;

            // Act - Submit 20 tasks to get singleton instance
            for (int i = 0; i < threadCount; i++) {
                executor.execute(() -> {
                    instances.add(GameController.getInstance());
                });
            }

            // Shutdown and wait for all threads to complete
            executor.shutdown();
            boolean completed = executor.awaitTermination(10, TimeUnit.SECONDS);

            // Assert
            assertTrue(completed, "All threads should complete within timeout");
            assertEquals(1, instances.size(), "All threads should receive the same singleton instance");
        }

        /**
         * Test Case: GameControllerSingletonTest.testHighConcurrencyThreadSafety()
         * 
         * Tests thread safety with even higher concurrency (50 threads).
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: 50 concurrent threads attempting to get singleton instance
         * Expected Outcome: All threads receive the same instance; no race conditions occur
         * Testing Framework: JUnit 5, ExecutorService with high thread count
         */
        @Test
        @DisplayName("testHighConcurrencyThreadSafety - 50 concurrent threads get same instance")
        void testHighConcurrencyThreadSafety() throws InterruptedException {
            // Arrange
            Set<GameController> instances = new HashSet<>();
            ExecutorService executor = Executors.newFixedThreadPool(50);
            int threadCount = 50;
            AtomicInteger successCount = new AtomicInteger(0);

            // Act
            for (int i = 0; i < threadCount; i++) {
                executor.execute(() -> {
                    GameController instance = GameController.getInstance();
                    if (instance != null) {
                        instances.add(instance);
                        successCount.incrementAndGet();
                    }
                });
            }

            // Shutdown and wait
            executor.shutdown();
            boolean completed = executor.awaitTermination(15, TimeUnit.SECONDS);

            // Assert
            assertTrue(completed, "All 50 threads should complete");
            assertEquals(threadCount, successCount.get(), "All threads should successfully get instance");
            assertEquals(1, instances.size(), "All threads should get the same singleton instance");
        }

        /**
         * Test Case: GameControllerSingletonTest.testConcurrentAccessConsistency()
         * 
         * Tests that concurrent access to getInstance() produces consistent results.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: Multiple rapid successive calls from different threads
         * Expected Outcome: All instances are identical; no instance creation conflicts
         * Testing Framework: JUnit 5 with ExecutorService
         */
        @Test
        @DisplayName("testConcurrentAccessConsistency - Rapid concurrent access remains consistent")
        void testConcurrentAccessConsistency() throws InterruptedException {
            // Arrange
            Set<Integer> hashCodes = new HashSet<>();
            ExecutorService executor = Executors.newFixedThreadPool(10);

            // Act
            for (int i = 0; i < 100; i++) {
                executor.execute(() -> {
                    GameController instance = GameController.getInstance();
                    hashCodes.add(System.identityHashCode(instance));
                });
            }

            executor.shutdown();
            executor.awaitTermination(10, TimeUnit.SECONDS);

            // Assert
            assertEquals(1, hashCodes.size(),
                    "All concurrent accesses should return instance with same hash code");
        }
    }

    /**
     * Nested test class for instance behavior and state tests.
     */
    @Nested
    @DisplayName("Instance Behavior Tests")
    class InstanceBehaviorTests {

        /**
         * Test Case: GameControllerSingletonTest.testInstanceIsRunnableInterface()
         * 
         * Tests that the singleton instance implements the Runnable interface.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: None
         * Expected Outcome: getInstance() returns a Runnable object
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testInstanceIsRunnableInterface - Instance implements Runnable")
        void testInstanceIsRunnableInterface() {
            // Arrange & Act
            GameController instance = GameController.getInstance();

            // Assert
            assertNotNull(instance, "Instance should not be null");
            assertTrue(instance instanceof Runnable,
                    "GameController singleton should implement Runnable interface");
        }

        /**
         * Test Case: GameControllerSingletonTest.testInstanceClassCorrect()
         * 
         * Tests that the singleton instance is of the correct class type.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: None
         * Expected Outcome: getInstance() returns instance of GameController class
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testInstanceClassCorrect - Instance is of GameController type")
        void testInstanceClassCorrect() {
            // Arrange & Act
            GameController instance = GameController.getInstance();

            // Assert
            assertEquals(GameController.class, instance.getClass(),
                    "getInstance() should return GameController instance");
        }
    }

    /**
     * Nested test class for lazy initialization tests.
     */
    @Nested
    @DisplayName("Lazy Initialization Tests")
    class LazyInitializationTests {

        /**
         * Test Case: GameControllerSingletonTest.testLazyInitialization()
         * 
         * Tests that the singleton instance is created only when getInstance() is first called.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: Fresh test execution
         * Expected Outcome: First getInstance() call creates instance; subsequent calls return it
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testLazyInitialization - Instance created on first getInstance() call")
        void testLazyInitialization() {
            // Arrange - Get first instance
            GameController firstInstance = GameController.getInstance();

            // Assert - Instance should not be null (created on demand)
            assertNotNull(firstInstance, "First getInstance() call should create instance (lazy init)");

            // Act - Get second instance
            GameController secondInstance = GameController.getInstance();

            // Assert - Second instance should be identical
            assertSame(firstInstance, secondInstance,
                    "Second getInstance() call should return existing instance");
        }
    }

    /**
     * Nested test class for edge case tests.
     */
    @Nested
    @DisplayName("Edge Case Tests")
    class EdgeCaseTests {

        /**
         * Test Case: GameControllerSingletonTest.testSequentialAccess()
         * 
         * Tests that sequential rapid calls to getInstance() return same instance.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: Rapid sequential calls (100 times)
         * Expected Outcome: All 100 calls return the same instance object
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testSequentialAccess - 100 sequential calls return same instance")
        void testSequentialAccess() {
            // Arrange
            GameController firstInstance = GameController.getInstance();
            Set<GameController> uniqueInstances = new HashSet<>();

            // Act
            for (int i = 0; i < 100; i++) {
                uniqueInstances.add(GameController.getInstance());
            }

            // Assert
            assertEquals(1, uniqueInstances.size(),
                    "100 sequential calls should return exactly 1 unique instance");
            assertTrue(uniqueInstances.contains(firstInstance),
                    "All calls should return the same instance");
        }

        /**
         * Test Case: GameControllerSingletonTest.testMultipleReferencesPointToSameObject()
         * 
         * Tests that multiple variable assignments point to the same object.
         * 
         * Class and Method under test: GameController.getInstance()
         * Test Inputs/Preconditions: 5 separate variable assignments from getInstance()
         * Expected Outcome: All variables reference identical object in memory
         * Testing Framework: JUnit 5
         */
        @Test
        @DisplayName("testMultipleReferencesPointToSameObject - All references point to same object")
        void testMultipleReferencesPointToSameObject() {
            // Arrange & Act
            GameController ref1 = GameController.getInstance();
            GameController ref2 = GameController.getInstance();
            GameController ref3 = GameController.getInstance();
            GameController ref4 = GameController.getInstance();
            GameController ref5 = GameController.getInstance();

            // Assert
            assertSame(ref1, ref2, "ref1 and ref2 should be identical");
            assertSame(ref2, ref3, "ref2 and ref3 should be identical");
            assertSame(ref3, ref4, "ref3 and ref4 should be identical");
            assertSame(ref4, ref5, "ref4 and ref5 should be identical");
        }
    }
}
